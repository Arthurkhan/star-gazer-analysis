import { jsPDF } from 'jspdf';
import autoTable from 'jspdf-autotable';
import { HistoricalTrend, ReviewCluster, TemporalPattern, SeasonalPattern } from '@/types/dataAnalysis';
import { BusinessType } from '@/types/businessTypes';

// Add type definition for jsPDF with autoTable
declare module 'jspdf' {
  interface jsPDF {
    autoTable: typeof autoTable;
  }
}

export interface ExportOptions {
  businessName: string;
  businessType: BusinessType;
  includeCharts: boolean;
  includeTables: boolean;
  includeRecommendations: boolean;
  dateRange?: { start: Date; end: Date };
  customTitle?: string;
  brandingColor?: string;
  logo?: string; // URL or base64 image
}

export interface ExportData {
  historicalTrends?: HistoricalTrend[];
  reviewClusters?: ReviewCluster[];
  temporalPatterns?: TemporalPattern[];
  seasonalPatterns?: SeasonalPattern[];
  recommendations?: {
    urgent: string[];
    growth: string[];
    marketing: string[];
    competitive: string[];
  };
  insights?: {
    keyFindings: string[];
    opportunities: string[];
    risks: string[];
  };
}

/**
 * Generate a PDF report based on the provided data and options
 */
export function generatePDF(data: ExportData, options: ExportOptions): jsPDF {
  // Initialize PDF document
  const doc = new jsPDF();
  
  // Add header with title and branding
  addHeader(doc, options);
  
  // Add date range if provided
  if (options.dateRange) {
    const dateFormat = new Intl.DateTimeFormat('en-US', { 
      year: 'numeric', month: 'short', day: 'numeric' 
    });
    const startDate = dateFormat.format(options.dateRange.start);
    const endDate = dateFormat.format(options.dateRange.end);
    doc.setFontSize(10);
    doc.setTextColor(100, 100, 100);
    doc.text(`Report Period: ${startDate} to ${endDate}`, 105, 25, { align: 'center' });
  }
  
  // Reset text color for rest of document
  doc.setTextColor(0, 0, 0);
  
  let yPosition = 35;
  
  // Add key metrics summary
  if (data?.historicalTrends?.length) {
    yPosition = addKeyMetricsSummary(doc, data, yPosition);
  }
  
  // Add insights
  if (data?.insights) {
    yPosition = addInsightsSection(doc, data.insights, yPosition);
  }
  
  // Add review clusters if requested
  if (options.includeTables && data?.reviewClusters?.length) {
    yPosition = addReviewClusters(doc, data.reviewClusters, yPosition);
  }
  
  // Add recommendations if requested
  if (options.includeRecommendations && data?.recommendations) {
    yPosition = addRecommendations(doc, data.recommendations, yPosition);
  }
  
  // Add seasonal patterns
  if (data?.seasonalPatterns?.length) {
    yPosition = addSeasonalPatterns(doc, data.seasonalPatterns, yPosition);
  }
  
  // Add footer with page numbers
  const pageCount = doc.internal.getNumberOfPages();
  for (let i = 1; i <= pageCount; i++) {
    doc.setPage(i);
    doc.setFontSize(8);
    doc.setTextColor(100, 100, 100);
    doc.text(`Page ${i} of ${pageCount} - Generated by StarGazer Analysis on ${new Date().toLocaleDateString()}`, 105, 290, { align: 'center' });
  }
  
  return doc;
}

/**
 * Add header to the PDF
 */
function addHeader(doc: jsPDF, options: ExportOptions): void {
  const brandingColor = hexToRgb(options.brandingColor || '#3B82F6'); // Default blue
  const title = options.customTitle || `${options.businessName} - Review Analysis`;
  
  // Add background rectangle for header
  doc.setFillColor(brandingColor.r, brandingColor.g, brandingColor.b);
  doc.rect(0, 0, 210, 20, 'F');
  
  // Add title
  doc.setTextColor(255, 255, 255);
  doc.setFontSize(18);
  doc.text(title, 105, 12, { align: 'center' });
  
  // Add logo if provided
  if (options.logo) {
    try {
      doc.addImage(options.logo, 'PNG', 10, 2, 16, 16);
    } catch (error) {
      console.error('Error adding logo image:', error);
    }
  }
}

/**
 * Add key metrics summary to the PDF
 */
function addKeyMetricsSummary(doc: jsPDF, data: ExportData, startY: number): number {
  // Add safety checks for data
  if (!data || !data.historicalTrends || data.historicalTrends.length === 0) {
    return startY;
  }
  
  const historicalTrend = data.historicalTrends[0]; // Use first trend for summary
  
  // Check if historicalTrend has valid data
  if (!historicalTrend || !historicalTrend.data || historicalTrend.data.length === 0) {
    return startY;
  }
  
  const reviewClusters = data.reviewClusters || [];
  
  doc.setFontSize(14);
  doc.setFont('helvetica', 'bold');
  doc.text('Key Metrics', 14, startY);
  doc.setFont('helvetica', 'normal');
  
  // Create metrics table
  const latestPeriodData = historicalTrend.data[historicalTrend.data.length - 1];
  const previousPeriodData = historicalTrend.data[historicalTrend.data.length - 2] || { value: 0 };
  const changePercentage = ((latestPeriodData.percentageChange || 0)).toFixed(1) + '%';
  
  // Calculate total reviews
  const totalReviews = reviewClusters.reduce((total, cluster) => total + cluster.reviewCount, 0);
  
  // Get top cluster by review count
  const topCluster = reviewClusters.length > 0 ? 
    reviewClusters.sort((a, b) => b.reviewCount - a.reviewCount)[0].name : 
    'N/A';
  
  doc.autoTable({
    startY: startY + 5,
    head: [['Metric', 'Value', 'Change', 'Note']],
    body: [
      [`${historicalTrend.metric}`, 
       `${latestPeriodData.value.toFixed(2)}`,
       `${changePercentage}`,
       `Trend: ${historicalTrend.trend}`],
      ['Total Reviews', 
       `${totalReviews}`, 
       '', 
       `Across ${reviewClusters.length} clusters`],
      ['Top Cluster', 
       `${topCluster}`, 
       '', 
       'By review volume']
    ],
    theme: 'grid',
    styles: { fontSize: 10 },
    headStyles: { fillColor: [59, 130, 246], textColor: [255, 255, 255] },
  });
  
  return (doc as any).lastAutoTable.finalY + 10;
}

/**
 * Add insights section to the PDF
 */
function addInsightsSection(doc: jsPDF, insights: ExportData['insights'], startY: number): number {
  if (!insights) return startY;
  
  doc.setFontSize(14);
  doc.setFont('helvetica', 'bold');
  doc.text('Key Insights', 14, startY);
  doc.setFont('helvetica', 'normal');
  
  let currentY = startY + 7;
  
  // Add key findings
  if (insights.keyFindings && insights.keyFindings.length > 0) {
    doc.setFontSize(11);
    doc.setFont('helvetica', 'bold');
    doc.text('Key Findings:', 14, currentY);
    doc.setFont('helvetica', 'normal');
    
    currentY += 5;
    insights.keyFindings.forEach(finding => {
      doc.setFontSize(10);
      
      // Handle text wrapping
      const textLines = doc.splitTextToSize(finding, 180);
      doc.text('• ' + textLines[0], 20, currentY);
      
      // Handle multiple lines
      if (textLines.length > 1) {
        for (let i = 1; i < textLines.length; i++) {
          currentY += 5;
          doc.text('  ' + textLines[i], 20, currentY);
        }
      }
      
      currentY += 7;
    });
  }
  
  // Add opportunities
  if (insights.opportunities && insights.opportunities.length > 0) {
    // Check if we need a new page
    if (currentY > 250) {
      doc.addPage();
      currentY = 20;
    }
    
    doc.setFontSize(11);
    doc.setFont('helvetica', 'bold');
    doc.text('Opportunities:', 14, currentY);
    doc.setFont('helvetica', 'normal');
    
    currentY += 5;
    insights.opportunities.forEach(opportunity => {
      doc.setFontSize(10);
      
      // Handle text wrapping
      const textLines = doc.splitTextToSize(opportunity, 180);
      doc.text('• ' + textLines[0], 20, currentY);
      
      // Handle multiple lines
      if (textLines.length > 1) {
        for (let i = 1; i < textLines.length; i++) {
          currentY += 5;
          doc.text('  ' + textLines[i], 20, currentY);
        }
      }
      
      currentY += 7;
    });
  }
  
  // Add risks
  if (insights.risks && insights.risks.length > 0) {
    // Check if we need a new page
    if (currentY > 250) {
      doc.addPage();
      currentY = 20;
    }
    
    doc.setFontSize(11);
    doc.setFont('helvetica', 'bold');
    doc.text('Risks:', 14, currentY);
    doc.setFont('helvetica', 'normal');
    
    currentY += 5;
    insights.risks.forEach(risk => {
      doc.setFontSize(10);
      
      // Handle text wrapping
      const textLines = doc.splitTextToSize(risk, 180);
      doc.text('• ' + textLines[0], 20, currentY);
      
      // Handle multiple lines
      if (textLines.length > 1) {
        for (let i = 1; i < textLines.length; i++) {
          currentY += 5;
          doc.text('  ' + textLines[i], 20, currentY);
        }
      }
      
      currentY += 7;
    });
  }
  
  return currentY + 5;
}

/**
 * Add review clusters section to the PDF
 */
function addReviewClusters(doc: jsPDF, clusters: ReviewCluster[], startY: number): number {
  // Check if we need a new page
  if (startY > 250) {
    doc.addPage();
    startY = 20;
  }
  
  doc.setFontSize(14);
  doc.setFont('helvetica', 'bold');
  doc.text('Review Clusters', 14, startY);
  doc.setFont('helvetica', 'normal');
  
  // Prepare cluster data for the table
  const tableBody = clusters
    .sort((a, b) => {
      // Keep special clusters at top (Delighted and Dissatisfied)
      if (a.name === 'Delighted Customers') return -1;
      if (b.name === 'Delighted Customers') return 1;
      if (a.name === 'Dissatisfied Customers') return -1;
      if (b.name === 'Dissatisfied Customers') return 1;
      
      // Otherwise sort by review count
      return b.reviewCount - a.reviewCount;
    })
    .slice(0, 6) // Limit to 6 clusters for space
    .map(cluster => [
      cluster.name,
      cluster.reviewCount.toString(),
      cluster.averageRating.toFixed(1),
      cluster.sentiment.charAt(0).toUpperCase() + cluster.sentiment.slice(1),
      cluster.keywords.slice(0, 3).join(', ')
    ]);
  
  // Add the table
  doc.autoTable({
    startY: startY + 5,
    head: [['Cluster', 'Reviews', 'Avg Rating', 'Sentiment', 'Top Keywords']],
    body: tableBody,
    theme: 'grid',
    styles: { fontSize: 9 },
    headStyles: { fillColor: [59, 130, 246], textColor: [255, 255, 255] },
    columnStyles: {
      0: { cellWidth: 60 },
      1: { cellWidth: 25, halign: 'center' },
      2: { cellWidth: 25, halign: 'center' },
      3: { cellWidth: 30 },
      4: { cellWidth: 50 }
    }
  });
  
  return (doc as any).lastAutoTable.finalY + 10;
}

/**
 * Add recommendations section to the PDF
 */
function addRecommendations(doc: jsPDF, recommendations: ExportData['recommendations'], startY: number): number {
  if (!recommendations) return startY;
  
  // Check if we need a new page
  if (startY > 230) {
    doc.addPage();
    startY = 20;
  }
  
  doc.setFontSize(14);
  doc.setFont('helvetica', 'bold');
  doc.text('Recommendations', 14, startY);
  doc.setFont('helvetica', 'normal');
  
  let currentY = startY + 7;
  
  // Add urgent recommendations
  if (recommendations.urgent?.length) {
    doc.setFontSize(11);
    doc.setFont('helvetica', 'bold');
    doc.setTextColor(220, 38, 38); // Red color for urgent
    doc.text('Urgent Actions:', 14, currentY);
    doc.setTextColor(0, 0, 0);
    doc.setFont('helvetica', 'normal');
    
    currentY += 5;
    recommendations.urgent.forEach(rec => {
      doc.setFontSize(10);
      
      // Handle text wrapping
      const textLines = doc.splitTextToSize(rec, 180);
      doc.text('• ' + textLines[0], 20, currentY);
      
      // Handle multiple lines
      if (textLines.length > 1) {
        for (let i = 1; i < textLines.length; i++) {
          currentY += 5;
          doc.text('  ' + textLines[i], 20, currentY);
        }
      }
      
      currentY += 7;
    });
  }
  
  // Add growth recommendations
  if (recommendations.growth?.length) {
    // Check if we need a new page
    if (currentY > 250) {
      doc.addPage();
      currentY = 20;
    }
    
    doc.setFontSize(11);
    doc.setFont('helvetica', 'bold');
    doc.setTextColor(16, 185, 129); // Green color for growth
    doc.text('Growth Strategy:', 14, currentY);
    doc.setTextColor(0, 0, 0);
    doc.setFont('helvetica', 'normal');
    
    currentY += 5;
    recommendations.growth.forEach(rec => {
      doc.setFontSize(10);
      
      // Handle text wrapping
      const textLines = doc.splitTextToSize(rec, 180);
      doc.text('• ' + textLines[0], 20, currentY);
      
      // Handle multiple lines
      if (textLines.length > 1) {
        for (let i = 1; i < textLines.length; i++) {
          currentY += 5;
          doc.text('  ' + textLines[i], 20, currentY);
        }
      }
      
      currentY += 7;
    });
  }
  
  // Add more recommendation categories as needed...
  
  return currentY + 5;
}

/**
 * Add seasonal patterns section to the PDF
 */
function addSeasonalPatterns(doc: jsPDF, patterns: SeasonalPattern[], startY: number): number {
  // Check if we need a new page
  if (startY > 250) {
    doc.addPage();
    startY = 20;
  }
  
  doc.setFontSize(14);
  doc.setFont('helvetica', 'bold');
  doc.text('Seasonal Analysis', 14, startY);
  doc.setFont('helvetica', 'normal');
  
  // Prepare seasonal data for the table
  const tableBody = patterns
    .map(pattern => [
      pattern.name,
      `${pattern.dateRange.start} - ${pattern.dateRange.end}`,
      pattern.metrics.avgRating.toFixed(1),
      pattern.metrics.reviewVolume.toString(),
      `${pattern.comparison.vsYearAverage > 0 ? '+' : ''}${pattern.comparison.vsYearAverage.toFixed(1)}%`,
      pattern.metrics.topThemes.slice(0, 2).join(', ')
    ]);
  
  // Add the table
  doc.autoTable({
    startY: startY + 5,
    head: [['Season', 'Date Range', 'Avg Rating', 'Reviews', 'vs Avg', 'Top Themes']],
    body: tableBody,
    theme: 'grid',
    styles: { fontSize: 9 },
    headStyles: { fillColor: [59, 130, 246], textColor: [255, 255, 255] },
  });
  
  return (doc as any).lastAutoTable.finalY + 10;
}

/**
 * Convert hex color to RGB
 */
function hexToRgb(hex: string): { r: number; g: number; b: number } {
  // Default color if invalid hex is provided
  const defaultColor = { r: 59, g: 130, b: 246 }; // Default blue
  
  // Check if valid hex
  if (!hex || hex.length < 7 || !hex.startsWith('#')) {
    return defaultColor;
  }
  
  try {
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    
    if (isNaN(r) || isNaN(g) || isNaN(b)) {
      return defaultColor;
    }
    
    return { r, g, b };
  } catch (error) {
    console.error('Error parsing hex color:', error);
    return defaultColor;
  }
}

/**
 * Export data to CSV format
 */
export function exportToCSV(data: ExportData, options: ExportOptions): string {
  let csvContent = '';
  
  // Add header with business info
  csvContent += `# ${options.businessName} - Review Analysis\n`;
  if (options.dateRange) {
    const dateFormat = new Intl.DateTimeFormat('en-US', { 
      year: 'numeric', month: 'short', day: 'numeric' 
    });
    csvContent += `# Period: ${dateFormat.format(options.dateRange.start)} to ${dateFormat.format(options.dateRange.end)}\n`;
  }
  csvContent += `# Generated: ${new Date().toLocaleDateString()}\n\n`;
  
  // Add review clusters
  if (data?.reviewClusters?.length) {
    csvContent += '## REVIEW CLUSTERS\n';
    csvContent += 'Name,Reviews,Rating,Sentiment,Keywords\n';
    
    data.reviewClusters.forEach(cluster => {
      csvContent += `"${cluster.name}",`;
      csvContent += `${cluster.reviewCount},`;
      csvContent += `${cluster.averageRating.toFixed(1)},`;
      csvContent += `"${cluster.sentiment}",`;
      csvContent += `"${cluster.keywords.slice(0, 5).join(', ')}"\n`;
    });
    
    csvContent += '\n';
  }
  
  // Add historical trends
  if (data?.historicalTrends?.length) {
    csvContent += '## HISTORICAL TRENDS\n';
    
    data.historicalTrends.forEach(trend => {
      csvContent += `# ${trend.metric} (${trend.timeframe})\n`;
      csvContent += 'Period,Value,Change(%)\n';
      
      trend.data.forEach(point => {
        csvContent += `"${point.period}",`;
        csvContent += `${point.value},`;
        csvContent += `${point.percentageChange.toFixed(2)}\n`;
      });
      
      csvContent += '\n';
    });
  }
  
  // Add insights
  if (data?.insights) {
    csvContent += '## INSIGHTS\n';
    
    if (data.insights.keyFindings?.length) {
      csvContent += '# Key Findings\n';
      data.insights.keyFindings.forEach(finding => {
        csvContent += `"${finding}"\n`;
      });
      csvContent += '\n';
    }
    
    if (data.insights.opportunities?.length) {
      csvContent += '# Opportunities\n';
      data.insights.opportunities.forEach(opportunity => {
        csvContent += `"${opportunity}"\n`;
      });
      csvContent += '\n';
    }
    
    if (data.insights.risks?.length) {
      csvContent += '# Risks\n';
      data.insights.risks.forEach(risk => {
        csvContent += `"${risk}"\n`;
      });
      csvContent += '\n';
    }
  }
  
  // Add recommendations
  if (data?.recommendations) {
    csvContent += '## RECOMMENDATIONS\n';
    
    if (data.recommendations.urgent?.length) {
      csvContent += '# Urgent Actions\n';
      data.recommendations.urgent.forEach(rec => {
        csvContent += `"${rec}"\n`;
      });
      csvContent += '\n';
    }
    
    if (data.recommendations.growth?.length) {
      csvContent += '# Growth Strategy\n';
      data.recommendations.growth.forEach(rec => {
        csvContent += `"${rec}"\n`;
      });
      csvContent += '\n';
    }
    
    if (data.recommendations.marketing?.length) {
      csvContent += '# Marketing Plan\n';
      data.recommendations.marketing.forEach(rec => {
        csvContent += `"${rec}"\n`;
      });
      csvContent += '\n';
    }
    
    if (data.recommendations.competitive?.length) {
      csvContent += '# Competitive Strategy\n';
      data.recommendations.competitive.forEach(rec => {
        csvContent += `"${rec}"\n`;
      });
      csvContent += '\n';
    }
  }
  
  return csvContent;
}
